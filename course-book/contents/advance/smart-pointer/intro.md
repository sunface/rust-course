# 智能指针
在各个编程语言中，指针的概念几乎都是相同的：**指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据**。

在Rust中，最常见的指针类型是引用，引用通过`&`符号表示。不同于其它语言，引用在Rust中被赋予了更深层次的含义那就是：借用了其它变量的值。引用本身很简单，除了指向某个值外并没有其它的功能，也不会造成性能上的额外损耗，因此是Rust中使用最多的指针类型。

而智能指针则不然，它虽然也号称指针，但是它是一个复杂的家伙：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。总之，Rust的智能指针并不是独创，在C++或者其他语言中也存在相似的概念。

Rust标准库中定义的那些智能指针，虽重但强，可以提供比引用更多的功能特性，例如本章将讨论的引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。

引用和智能指针的另一个不同在于前者仅仅是借用了数据，而后者往往可以拥有它们指向的数据，然后再为其它人提供服务。

在之前的章节中，实际上我们已经见识过多种智能指针，例如动态字符串`String`和动态数组`Vec`，它们的数据结构中不仅仅包含了指向底层数据的指针，还包含了当前长度、最大长度等信息，其中`String`智能指针还提供了一种担保信息：所有的数据都是合法的`UTF-8`格式。


智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了`Deref`和`Drop`特征：

- `Deref`可以让智能指针像引用那样工作，这样你就就可以写出同时支持智能指针和引用的代码, 例如`&T`
- `Drop`允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作

鉴于智能指针在Rust中很常见，因此我们在本章不会全部讲解，而是挑选几个最常用、最有代表性的进行讲解：

- `Box<T>`， 可以将值分配到堆上
- `Rc<T>`, 引用计数类型，允许多所有权存在
- `Ref<T>`和`RefMut<T>`, 允许将借用规则检查从编译期移动到运行期进行