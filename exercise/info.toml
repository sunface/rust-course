# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
æç¤º: ç¬¬ 12 è¡Œçš„å˜é‡å£°æ˜ç¼ºå°‘äº†ä¸€ä¸ªå…³é”®å­—ï¼Œåœ¨ Rust ä¸­ï¼Œåˆ›å»ºä¸€ä¸ª
æ–°çš„å˜é‡ç»‘å®šå¿…é¡»ç”¨åˆ°è¿™ä¸ªå…³é”®å­—ã€‚"""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
ç¼–è¯‘å™¨åœ¨è¯´ï¼ŒRust æ— æ³•æ ¹æ®ç»™å®šå†…å®¹æ¨æ–­å‡ºå˜é‡ `x` çš„ç±»å‹.
å¦‚æœä½ å¯¹ç¬¬ 7 è¡Œæ ‡æ³¨ç±»å‹ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
å¦‚æœä½ å¯¹ x èµ‹äºˆä¸€ä¸ªå€¼å‘¢ï¼Ÿ
å¦‚æœä½ åŒæ—¶åšåˆ°äº†ä»¥ä¸Šä¸¤ç‚¹å‘¢ï¼Ÿ
 x åˆ°åº•æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ
å¦‚æœ x ä¸ 10 æ˜¯åŒä¸€ç±»å‹ï¼Œäº¦æˆ–è€…å®ƒæ˜¯ä¸åŒçš„ç±»å‹å‘¢ï¼Ÿ"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
åœ¨ Rustï¼Œå˜é‡ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ã€‚ä½†æˆ‘ä»¬æ­£è¯•å›¾é‡æ–°åˆ†é…
ä¸€ä¸ªä¸åŒçš„å€¼ç»™ x ï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå…³é”®å­—ä½¿å˜é‡å¯å˜ã€‚"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
ç³Ÿäº†ï¼åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬åœ¨ç¬¬ 7 è¡Œåˆ›å»ºäº†ä¸€ä¸ªå˜é‡ï¼Œç„¶åè¯•å›¾åœ¨ç¬¬ 8 è¡Œ
ä½¿ç”¨å®ƒï¼Œä½†æ˜¯å®ƒå¹¶æ²¡è¢«èµ‹å€¼ï¼æˆ‘ä»¬æ— æ³•æ‰“å°å‡ºä¸å­˜åœ¨çš„å†…å®¹ï¼Œæ‰€ä»¥å°è¯•èµ‹äºˆ x ä¸€ä¸ªå€¼ï¼
è¿™ä¸ªé”™è¯¯é€ æˆçš„ Bug åœ¨ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­éƒ½éå¸¸å®¹æ˜“å‘ç”Ÿâ€”â€”æ„Ÿè°¢ Rust ç¼–è¯‘å™¨æé†’äº†æˆ‘ä»¬"""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
åœ¨ variables3 ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„å…³é”®å­—ä½¿ä¸€ä¸ªä¸å¯å˜çš„å˜é‡å˜å¾—å¯å˜ã€‚
å¯æƒœçš„æ˜¯ï¼Œåœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œè¿™ä¸ªæ–¹æ³•å¹¶ä¸ç®¡ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ç»™ä¸€ä¸ªç°æœ‰çš„å˜é‡åˆ†é…ä¸€ä¸ªä¸
åŒç±»å‹çš„å€¼ã€‚æœ‰æ—¶ï¼Œä½ ä¼šæƒ³é‡å¤ä½¿ç”¨ç°æœ‰çš„å˜é‡åç§°ï¼Œå› ä¸ºä½ åªæ˜¯å°†æ•°å€¼è½¬æ¢ä¸ºä¸åŒçš„ç±»å‹ï¼Œå°±åƒ
æœ¬ç»ƒä¹ ä¸­ä¸€æ ·ã€‚å¹¸è¿çš„æ˜¯ï¼ŒRust æœ‰ä¸€ä¸ªå¼ºå¤§çš„æŠ€æœ¯å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šå˜é‡é®è”½ï¼ˆShadowingï¼‰ï¼
æœ‰å…³å˜é‡é®è”½çš„æ›´å¤šå†…å®¹å¯é€šè¿‡è¿™æœ¬ä¹¦çš„ 'Variables and Mutability'* ç« èŠ‚äº†è§£:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
å°è¯•ä½¿ç”¨æ­¤æŠ€æœ¯è§£å†³æ­¤ç»ƒä¹ ã€‚

è¯‘ï¼šVariables and Mutabilityï¼šå˜é‡ä¸å¯å˜æ€§"""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
æˆ‘ä»¬å·²ç»äº†è§£äº†å˜é‡ä¸å¯å˜æ€§ï¼Œä½†è¿˜æœ‰å¦ä¸€ç§é‡è¦çš„å˜é‡ç±»å‹ï¼›å¸¸é‡ï¼ˆConstantï¼‰ã€‚ 
å¸¸é‡æ°¸è¿œä¸å¯æ”¹å˜çš„ï¼Œå®ƒç”¨å…³é”®å­— 'const' è€Œéå…³é”®å­— 'let' å£°æ˜ï¼Œå¹¶ä¸”å…¶ç±»å‹ä¹Ÿå¿…é¡»è¢«æ ‡æ³¨ã€‚

æ›´å¤šå…³äºå¸¸é‡çš„ä¿¡æ¯ 'Differences Between Variables and Constants'* åœ¨è¿™æœ¬ä¹¦çš„ç« èŠ‚ 'Variables and Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants

è¯‘ï¼šDifferences Between Variables and Constantsï¼šå˜é‡ä¸å¸¸é‡çš„åŒºåˆ«
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
ä¸»å‡½æ•°ä¸­æ­£è¯•å›¾è°ƒç”¨ä¸€ä¸ªåä¸º `call_me` çš„å‡½æ•°ï¼Œå¯è¿™ä¸ªå‡½æ•°å¹¶ä¸å­˜åœ¨ã€‚
å®ƒå¸Œæœ›è¿™ä¸ªå‡½æ•°ä¸æ¥å—ä»»ä½•å‚æ•°ï¼ŒåŒæ—¶ä¹Ÿä¸è¿”å›å€¼ã€‚
å¬èµ·æ¥å¾ˆåƒ `main` å‡½æ•°ï¼Œä¸æ˜¯å—ï¼Ÿ"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
 Rust è¦æ±‚å‡½æ•°ç­¾åï¼ˆsignatureï¼‰æœ‰ç±»å‹æ ‡æ³¨ï¼Œä½†æ˜¯ `call_me` å‡½æ•°ç¼ºå°‘ `num` çš„ç±»å‹æ ‡æ³¨ã€‚"""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
æ­¤æ—¶, å‡½æ•° *å£°æ˜ï¼ˆdeclarationï¼‰* æ˜¯æ²¡é—®é¢˜çš„ï¼Œä½†å‡½æ•°è°ƒç”¨å‡ºäº†é—®é¢˜"""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
é”™è¯¯ä¿¡æ¯æŒ‡å‘ç¬¬ 15 è¡Œï¼Œè¯´å¸Œæœ›åœ¨`->`ä¹‹åæœ‰ä¸€ä¸ªç±»å‹ã€‚
é‚£ä¸ªåœ°æ–¹æ ‡æ³¨äº†å‡½æ•°çš„è¿”å›ç±»å‹â€”â€”çœ‹çœ‹ `is_even` å‡½æ•°çš„ç¤ºä¾‹å§"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
è¿™æ˜¯ä¸€ä¸ªéå¸¸å¸¸è§çš„é”™è¯¯ï¼Œå¯ä»¥é€šè¿‡åˆ é™¤ä¸€ä¸ªå­—ç¬¦æ¥è§£å†³ã€‚
å‘ç”Ÿçš„åŸå› æ˜¯ Rust åŒºåˆ†äº†è¡¨è¾¾å¼å’Œè¯­å¥ï¼šè¡¨è¾¾å¼æ ¹æ®å…¶è¿ç®—æ•°ï¼ˆoperandï¼‰è¿”å›ä¸€ä¸ªå€¼, 
è€Œè¯­å¥ä»…è¿”å›ä¸€ä¸ª `()` ç±»å‹ï¼Œå…¶è¡Œä¸ºå¥½æ¯” C/C++ ä¸­çš„ `void` ã€‚
æˆ‘ä»¬å¸Œæœ› `square` å‡½æ•°è¿”å›ä¸€ä¸ª `i32` ç±»å‹çš„å€¼ï¼Œä½†ç°åœ¨å®ƒè¿”å›çš„æ˜¯ `()` ç±»å‹...
å®ƒä»¬æ˜¾ç„¶æ˜¯ä¸ä¸€æ ·çš„ã€‚å¯¹æ­¤æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆã€‚
1. åœ¨ `num * num;` å‰é¢åŠ ä¸Š `return` å…³é”®å­—
2. ç§»é™¤ `;`ï¼Œè®©å®ƒå˜æˆ `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œä¹Ÿå¯ä»¥ç”¨ä¸€è¡Œæ¥åšè¿™ä»¶äº‹!
å…¶ä»–è¯­è¨€ä¸­çš„ä¸€äº›ç±»ä¼¼ä¾‹å­:
- åœ¨ C(++) ä¸­ä¼šæ˜¯: `a > b ? a : b`
- åœ¨ Python ä¸­ä¼šæ˜¯:  `a if a > b else b`
è¯·è®°ä½åœ¨ Rust ä¸­ï¼š
- `if` çš„æ¡ä»¶ä¸éœ€è¦ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥
- `if`/`else` çš„æ¡ä»¶æ˜¯è¡¨è¾¾å¼
- æ¯ä¸ªæ¡ä»¶åé¢éƒ½æœ‰ä¸€ä¸ª `{}` å—ã€‚"""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
å¯¹äºç¬¬ä¸€ä¸ªç¼–è¯‘é”™è¯¯ï¼Œåœ¨äº Rust ä¸­çš„é‡è¦ä¸€ç‚¹ï¼š
æ¯ä¸ªæ¡ä»¶å—ï¼ˆconditional blockï¼‰éƒ½å¿…é¡»è¿”å›ç›¸åŒçš„ç±»å‹ã€‚
ä¸ºäº†é€šè¿‡æµ‹è¯•ï¼Œä½ éœ€è¦å‡ ä¸ªæ¡ä»¶ç”¨æ¥åˆ¤æ–­ä¸åŒçš„è¾“å…¥"""

# TEST 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "No hints this time ;)"

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
åœ¨ç¬¬ 13 è¡Œæœ‰ä¸ª "cannot borrow immutable local variable `vec1` as mutable"* é”™è¯¯ï¼Œå¯¹å—ï¼Ÿ
ä¿®å¤é”™è¯¯çš„æ–¹æ³•æ˜¯æ·»åŠ ä¸€ä¸ªå…³é”®è¯ï¼Œå¹¶ä¸”æ·»åŠ çš„ä½ç½®ä¸åœ¨æŠ¥é”™çš„ç¬¬ 13 è¡Œä¸Šã€‚

è¯‘æ³¨ï¼šä¸èƒ½å°†ä¸å¯å˜çš„å±€éƒ¨å˜é‡ `vec1` å€Ÿç”¨ä¸ºå¯å˜å˜é‡"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
å½“æˆ‘ä»¬åœ¨ç¬¬ 10 è¡Œè°ƒç”¨ `fill_vec` æ—¶ï¼Œ`vec0' è¢« *ç§»åŠ¨ï¼ˆmovedï¼‰* åˆ°
å‡½æ•° `fill_vec` ä¸­ï¼Œè¿™æ„å‘³ç€å®ƒä¼šåœ¨ `fill_vec` å‡½æ•°çš„æœ«å°¾è¢«ä¸¢å¼ƒï¼ŒåŒæ—¶ä¹Ÿ
å¯¼è‡´äº†æˆ‘ä»¬ä¸èƒ½åœ¨ç¬¬ 13 è¡Œå†æ¬¡ä½¿ç”¨ `vec0`ï¼ˆæˆ–åœ¨ `main` ä¸­è°ƒç”¨ `fill_vec` åçš„ä»»ä½•åœ°æ–¹ï¼‰ã€‚
æˆ‘ä»¬å¯ä»¥ç”¨å‡ ç§æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéƒ½è¯•ä¸€è¯•å§ï¼
1. åšä¸€ä¸ª `vec0` æ•°æ®çš„æ‹·è´ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ `fill_vec` ã€‚
2. è®© `fill_vec` é€šè¿‡å€Ÿç”¨è€Œä¸æ˜¯è·å–æ‰€æœ‰æƒçš„æ–¹å¼è·å–å‚æ•°ï¼Œç„¶ååœ¨å‡½æ•°ä¸­å¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œä»¥ä¾¿è¿”å›
   ä¸€ä¸ªå…·æœ‰æ‰€æœ‰æƒçš„ `Vec<i32>` å˜é‡ã€‚
3. è®© `fill_vec` å€Ÿç”¨å¯å˜å‚æ•°ï¼ˆå‚æ•°ä¹Ÿéœ€è¦å¯å˜ï¼‰ï¼Œç›´æ¥è¿›è¡Œæ“ä½œï¼Œç„¶åä¸è¿”å›ä»»ä½•ä¸œè¥¿ã€‚æ¥ç€ä½ éœ€è¦
   å®Œå…¨åœ°å»æ‰ `vec1`â€”â€”ä½†æ³¨æ„ï¼Œè¿™ä¹Ÿå°†æ”¹å˜ç¬¬ä¸€ä¸ª `println!` æ‰“å°å‡ºå†…å®¹ã€‚"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
ä¸ä¹‹å‰ä¸åŒï¼š`fn fill_vec` ç¬¬ä¸€è¡Œçš„ `let mut vec = vec;` ç°åœ¨å·²ç»ä¸å­˜åœ¨äº†ã€‚ 
ä½ å¯ä»¥åœ¨æŸä¸ªåœ°æ–¹æ·»åŠ  `mut` ä»¥ä½¿ç°æœ‰çš„ä¸å¯å˜ç»‘å®šå˜å¾—å¯å˜ï¼Œè€ŒéæŠŠä¸åŒçš„é‚£ä¸€è¡ŒåŠ å›å» :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
åªè¦ä½ è§‰å¾—æœ‰ç¡®åˆ‡çš„ç›®æ ‡ï¼Œå°±å¯ä»¥åœæ­¢é˜…è¯» :) æˆ–è€…è¯•ç€åšä¸€ä¸ªæ­¥éª¤ï¼Œç„¶åä¿®å¤ç¼–è¯‘é”™è¯¯ã€‚
å› æ­¤ï¼Œç›®æ ‡æœ‰ï¼š
   - å»æ‰ main ä¸­åˆ›å»ºæ–° vector çš„ç¬¬ä¸€è¡Œ
   - æ‰€ä»¥ `vec0` å·²ä¸å­˜åœ¨äº†ï¼Œä¸èƒ½å†æŠŠå®ƒä¼ ç»™ `fill_vec` ã€‚
   - ç°å·²ä¸éœ€è¦å‘ `fill_vec` ä¼ é€’ä»»ä½•ä¸œè¥¿ï¼Œæ‰€ä»¥å®ƒçš„ï¼ˆå‡½æ•°ï¼‰ç­¾ååº”è¯¥åæ˜ å‡ºå®ƒä¸æ¥å—ä»»ä½•å‚æ•°*ã€‚
   - ç”±äºå·²ä¸åœ¨ `main` åˆ›å»º vector ï¼Œæ‰€ä»¥éœ€è¦åœ¨ `fill_vec` ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ vectorï¼Œ
     ç±»ä¼¼äº `main` ä¸­çš„åšæ³•ã€‚
     
è¯‘æ³¨ï¼šç»ƒä¹ ä¸­ fill_vec çš„å‡½æ•°ç­¾åå·²ç»æ²¡æœ‰æ¥å—å‚æ•°äº†ï¼Œæ‰€ä»¥ä¼°è®¡æ˜¯åœ¨è°ƒç”¨çš„åœ°æ–¹"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
ä»”ç»†æ¨æ•²æ¯ä¸ªå¯å˜å¼•ç”¨çš„ä½¿ç”¨èŒƒå›´ã€‚
åœ¨è·å–å¯å˜å¼•ç”¨åæ˜¯å¦èƒ½å¤Ÿç«‹å³æ›´æ–°å¼•ç”¨ï¼ˆxï¼‰çš„å€¼ï¼Ÿ 
åœ¨æœ¬ä¹¦çš„ 'References and Borrowing' éƒ¨åˆ†äº†è§£æ›´å¤šå…³äº 'Mutable References' çš„ä¿¡æ¯ã€‚
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
"""

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
æœ‰ä¸€ç§ç®€ä¾¿çš„æ–¹æ³•å¯ä»¥åˆå§‹åŒ–å…·æœ‰ä¸€å®šå¤§å°çš„æ•°ç»„ï¼Œè€Œä¸éœ€è¦ä½ è¾“å…¥ 100 ä¸ª
å…ƒç´ ï¼ˆä½†å¦‚æœä½ æƒ³çš„è¯ï¼Œé‚£å½“ç„¶å¯ä»¥ï¼ï¼‰ã€‚
ä¾‹å¦‚ï¼Œä½ å¯ä»¥è¿™æ ·åšï¼š
let array = ["Are we there yet?"; 10];

é¢å¤–ç›®æ ‡: è¿˜æœ‰å“ªäº›ä¸œè¥¿å¯ä»¥åœ¨ `a.len()>=100` æ—¶è¿”å› true """

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
çœ‹çœ‹è¿™æœ¬ä¹¦çš„ï¼šUnderstanding Ownership -> Slices -> Other Slices ç« èŠ‚å§ï¼š
https://doc.rust-lang.org/book/ch04-03-slices.htmlï¼Œ
ç„¶åæ‰¾å‡ºæ‰€éœ€åˆ‡ç‰‡å…ƒç´ å¯¹åº”æ•°ç»„é‡Œçš„èµ·å§‹å’Œæˆªæ­¢ä¸‹æ ‡ã€‚ 

å¦‚æœä½ å¥½å¥‡æ—¢ç„¶ `assert_eq!` çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯å¼•ç”¨ï¼Œä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªå‚æ•°
æ²¡æœ‰ä½¿ç”¨ & å·ç”¨æ¥è¡¨ç¤ºå¼•ç”¨ï¼Œå¯ä»¥çœ‹çœ‹è¿™æœ¬ä¹¦çš„ Deref å¼ºåˆ¶è½¬æ¢éƒ¨åˆ†ï¼š
https://doc.rust-lang.org/book/ch15-02-deref.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
çœ‹çœ‹è¿™æœ¬ä¹¦çš„ Data Types -> The Tuple Type ç±»å‹ç« èŠ‚ï¼š
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
ç‰¹åˆ«æ˜¯å…³äºè§£æ„çš„éƒ¨åˆ†ï¼ˆè¿™èŠ‚ä¸­å€’æ•°ç¬¬äºŒä¸ªä¾‹å­ï¼‰ã€‚
ä½ éœ€è¦ä¸€ä¸ªæ¨¡å¼å°† `name` å’Œ `age` ç»‘å®šåˆ°å…ƒç»„çš„é€‚å½“éƒ¨åˆ†ã€‚ä½ èƒ½å¤Ÿåšåˆ°çš„ï¼ï¼"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
è™½ç„¶ä½ å¯ä»¥ä½¿ç”¨ `let` å¯¹å…ƒç»„è¿›è¡Œè§£æ„ ï¼Œä½†ä¸å¦¨è¯•è¯•å¯¹å®ƒè¿›è¡Œç´¢å¼•ï¼Œ
æ­£å¦‚è¿™æœ¬ä¹¦çš„ Data Types -> The Tuple Type éƒ¨åˆ†çš„æœ€åä¸€ä¸ªä¾‹å­è¡¨ç¤ºçš„é‚£æ ·ã€‚
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
ç°åœ¨ï¼Œä½ çš„å·¥å…·ç®±é‡Œåˆå¤šäº†ä¸€ä¸ªå·¥å…·ï¼"""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust ä¸åªæœ‰ä¸€ç§ç»“æ„ã€‚å®é™…ä¸Šï¼Œæ‰€æœ‰çš„å˜ä½“éƒ½æ˜¯ç”¨æ¥ç»„åˆç›¸å…³çš„æ•°æ®ã€‚
é¦–å…ˆæ˜¯ä¸€èˆ¬çš„ï¼ˆæˆ–ç»å…¸çš„ï¼‰ç»“æ„ï¼Œä¸€å—ç›¸å…³çš„æ•°æ®è¢«å‘½åä¸ºä¸€ä¸ªå­—æ®µé›†åˆã€‚
å…ƒç»„ç»“æ„åŸºæœ¬ä¸Šå°±æ˜¯è¢«å‘½åçš„å…ƒç»„ã€‚
æœ€åçš„å•å…ƒç»“æ„æ²¡æœ‰ä»»ä½•å­—æ®µï¼Œå¯¹æ³›å‹å¾ˆæœ‰ç”¨ã€‚

åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ éœ€è¦å®Œæˆå¹¶å®ç°æ¯ä¸€ç§ç»“æ„ã€‚
æ›´å¤šå…³äºç»“æ„çš„å†…å®¹åœ¨è¿™ï¼šhttps://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
åˆ›å»ºç»“æ„ä½“çš„å®ä¾‹å¾ˆç®€å•ï¼Œä½ åªéœ€è¦ç»™å®ƒçš„å­—æ®µåˆ†é…ä¸€äº›å€¼ã€‚
ç„¶è€Œï¼Œåœ¨å®ä¾‹åŒ–ç»“æ„æ—¶ï¼Œè¿˜æœ‰äº›æ·å¾„ã€‚
çœ‹çœ‹è¿™æœ¬ä¹¦ï¼Œæ¥äº†è§£æ›´å¤šï¼šhttps://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
Package å®ç°çš„ new æ–¹æ³•åœ¨é‡é‡ï¼ˆweight_in_gramsï¼‰ä¸ç¬¦åˆç‰©ç†çš„æƒ…å†µä¸‹éœ€è¦ panic :)ï¼Œè¿™åœ¨ Rust éœ€è¦æ€ä¹ˆåšï¼Ÿ

å¯¹äº is_internationalï¼šä¸€ä¸ªåŒ…è£¹å…·æœ‰å›½é™…æ€§çš„æ¡ä»¶æœ‰å“ªäº›ï¼Ÿä¼¼ä¹ä¸å®ƒæ‰€ç»è¿‡çš„åœ°æ–¹æœ‰å…³å§ï¼Ÿ

å¯¹äº calculate_transport_feesï¼šæ›´å¤§çš„é€šå¸¸æ›´è´µï¼Œæˆ‘ä»¬çš„ Package æ²¡æœ‰å°ºå¯¸ï¼Œä½†æœ‰äº›ä¸œè¥¿å¯èƒ½åŒæ ·ç¬¦åˆéœ€è¦ :)

çœ‹çœ‹è¿™æœ¬ä¹¦ï¼Œäº†è§£æ›´å¤šå…³äºæ–¹æ³•å®ç°çš„ä¿¡æ¯ï¼šhttps://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = """
æç¤ºï¼šæšä¸¾ç±»å‹è¿˜æ²¡æœ‰è¢«å®šä¹‰ã€‚"""

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
æç¤ºï¼šä½ å¯ä»¥åˆ›å»ºå¤šç§ä¸åŒç±»å‹çš„æšä¸¾ï¼Œå¦‚ä¸åŒ…å«å€¼ã€åŒ¿åç»“æ„*ã€å­—ç¬¦ä¸²ã€å…ƒç»„ï¼Œç­‰ç­‰ã€‚

è¯‘ï¼šåŒ¿åç»“æ„å¯èƒ½æ˜¯ä¸å‘½åå­—æ®µåçš„ç»“æ„"""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Rust ä¸­æ‰€æœ‰çš„ä¸œè¥¿é»˜è®¤éƒ½æ˜¯ç§æœ‰çš„ï¼ˆprivateï¼‰â€”â€”ä½†æ˜¯æœ‰ä¸ªå…³é”®å­—å¯ä»¥æ ‡æ˜æŸäº›ä¸œè¥¿ä¸ºå…¬å¼€çš„ï¼ˆpublicï¼‰ã€‚
è€Œç¼–è¯‘å™¨é”™è¯¯æ­£æŒ‡æ˜æŸäº›ä¸œè¥¿éœ€è¦èƒ½å¤Ÿè¢«å…¬å¼€è®¿é—®"""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
delicious_snacks æ¨¡å—è¯•å›¾æä¾›ä¸€ä¸ªåŒºåˆ«å…¶å†…éƒ¨ç»“æ„çš„å¤–éƒ¨æ¥å£ï¼ˆå¯¹äº `fruits` å’Œ `veggies` ä»¥åŠç›¸å…³çš„å¸¸æ•°ï¼‰ã€‚
å‚ç…§ main ä¸­çš„ä½¿ç”¨æƒ…å†µå®Œå–„ `use` è¯­å¥ï¼Œå¹¶æ‰¾åˆ°ä¸¤ä¸ªå¸¸é‡ä¸­ç¼ºå°‘çš„æŸä¸ªå…³é”®å­—ã€‚"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH å’Œ SystemTime å£°æ˜åœ¨ std::time æ¨¡å—ã€‚é€šè¿‡ `use` è¯­å¥
å°†å®ƒä»¬å¼•å…¥ä½œç”¨åŸŸã€‚ä½ å¯ä»¥ä½¿ç”¨åµŒå¥—è·¯å¾„ï¼ˆnested pathsï¼‰
æˆ–å…¨å±€æ“ä½œç¬¦ï¼ˆglob operatorï¼‰åªéœ€ä¸€è¡Œå°±èƒ½å¤Ÿå¼•å…¥å®ƒä»¬ã€‚

è¯‘ï¼šåµŒå¥—æ˜¯ {x,y,z} ï¼Œå…¨å±€æ˜¯ * """

# COLLECTIONS

[[exercises]]
name = "vec1"
path = "exercises/collections/vec1.rs"
mode = "test"
hint = """
Rust æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼å®šä¹‰ä¸€ä¸ª vector ã€‚
1. ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `Vec::new()` æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ vectorï¼Œç„¶å
   ä½¿ç”¨ `push()` æ–¹æ³•å¾€é‡Œé¢æ·»åŠ å…ƒç´ ã€‚
2. ç¬¬äºŒç§æ–¹æ³•æ›´ç®€å•ï¼Œé‚£å°±æ˜¯ä½¿ç”¨ `vec![]` å®ï¼Œæ¥ç€åœ¨å®çš„æ–¹æ‹¬å·å†…å®šä¹‰éœ€è¦çš„å…ƒç´ ã€‚
é˜…è¯»è¿™æœ¬ä¹¦çš„æ­¤ç« èŠ‚ï¼šhttps://doc.rust-lang.org/stable/book/ch08-01-vectors.html
æ¥äº†è§£æ›´å¤šã€‚
"""

[[exercises]]
name = "vec2"
path = "exercises/collections/vec2.rs"
mode = "test"
hint = """
æç¤º 1 ï¼š`i` æ˜¯ Vec ä¸­è¢«è¿­ä»£çš„æ¯ä¸ªå…ƒç´ ï¼Œä½ å¯ä»¥ä¹˜ä»¥å®ƒå—ï¼Ÿ
æç¤º 2 : ç ”ç©¶ä¸‹ç¼–è¯‘é”™è¯¯ç»™å‡ºçš„å»ºè®® ;)
"""

[[exercises]]
name = "hashmap1"
path = "exercises/collections/hashmap1.rs"
mode = "test"
hint = """
æç¤º 1 ï¼šçœ‹çœ‹å‡½æ•°çš„è¿”å›ç±»å‹ï¼Œæ¨æµ‹å‡º `basket` çš„ç±»å‹ã€‚
æç¤º 2 ï¼šæ°´æœçš„æ•°é‡åº”è¯¥ä¸å°‘äº 5 ä¸ªã€‚å¹¶ä¸”éœ€è¦ç¡®ä¿ç¯®å­é‡Œè‡³å°‘æœ‰ä¸‰ç§æ°´æœã€‚
"""

[[exercises]]
name = "hashmap2"
path = "exercises/collections/hashmap2.rs"
mode = "test"
hint = """
ä½¿ç”¨ `HashMap` ä¸­çš„ `entry()` å’Œ `or_insert()` æ¥å®Œæˆç›®æ ‡ã€‚
äº†è§£æ›´å¤šï¼šhttps://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value 
"""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
`current_favorite_color` å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸä¸º `'static` çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚
æˆ‘ä»¬çŸ¥é“è¿™ç‚¹æ˜¯å› ä¸ºå­—ç¬¦ä¸²ç›´æ¥å­˜å‚¨åœ¨äº†ä»£ç ä¸­â€”â€”å®ƒå¹¶ä¸æ¥è‡ªäºæ–‡ä»¶ã€ç”¨æˆ·è¾“å…¥æˆ–
å…¶ä»–ç¨‹åºâ€”â€”æ‰€ä»¥åªè¦ç¨‹åºè¿˜åœ¨è¿è¡Œï¼Œå®ƒå°±ä¼šä¸€ç›´å­˜åœ¨ã€‚ä½†å®ƒä»ç„¶æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚
æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥å°†å­—ç¬¦ä¸²åˆ‡ç‰‡è½¬æ¢ä¸º `String`ï¼Œè¿™åœ¨ä¹¦çš„ Strings ç« èŠ‚æœ‰æ‰€ä»‹ç»ï¼Œè¿˜æœ‰ä¸€ç§
æ–¹æ³•æ˜¯ä½¿ç”¨ `From` ç‰¹å¾"""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
æ˜¯çš„ï¼Œåªè¦æŠŠç»‘å®šåœ¨ `word` ä¸Šçš„å€¼æ”¹ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡è€Œé `String` å°±å¯ä»¥å¾ˆå®¹æ˜“åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸æ˜¯å—ï¼Ÿï¼Ÿ
æœ‰ä¸ªæ–¹æ³•æ˜¯åœ¨ç¬¬ 9 è¡Œæ·»ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™å°†å¼ºåˆ¶æŠŠ `String` è½¬ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚"""

# TEST 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "compile"
hint = "No hints this time ;)"

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Err` æ˜¯ `Result` çš„æˆå‘˜ä¹‹ä¸€ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªæµ‹è¯•çš„æ„æ€æ˜¯ `generate_nametag_text` 
åº”è¯¥è¿”å› `Result` è€Œä¸æ˜¯ `Option` ã€‚

è¦åšåˆ°è¿™äº›æ”¹å˜ï¼Œä½ éœ€è¦ï¼š
   - ä¿®æ”¹å‡½æ•°ç­¾åçš„è¿”å›ç±»å‹ä¸º Result<String, String>ï¼Œä»¥ä¾¿èƒ½è¿”å› `Ok(String)` å’Œ `Err(String)`ã€‚
   - æ›´æ”¹å‡½æ•°è¿”å›å€¼ `Some(stuff)` ä¸º `Ok(stuff)` ã€‚
   - æ›´æ”¹å‡½æ•°è¿”å›å€¼ `None` ä¸º `Err(error message)` ã€‚
   - å°†ç¬¬ä¸€ä¸ªæµ‹è¯•é¢„æœŸçš„å€¼ä» `Some(stuff)` æ”¹ä¸º `Ok(stuff)`ã€‚"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯å¯¹ `item_quantity.parse::<i32>()` ä½¿ç”¨ match è¯­å¥ï¼Œ
å…¶ä¸­æœ‰ä¸¤ç§æƒ…å†µéœ€è¦è¢«å¤„ç†ï¼Œåˆ†åˆ«æ˜¯ `Ok(something)` å’Œ `Err(something)`ã€‚
ä¸è¿‡è¿™ç§æ–¹æ³•åœ¨ Rust ä¸­å¾ˆå¸¸è§ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ª `?` æ“ä½œç¬¦ï¼Œä½œç”¨å‡ ä¹ç¬¦åˆä½ æƒ³è®©åŒ¹é…è¯­å¥åšçš„äº‹ï¼
çœ‹ä¸€ä¸‹ Error Handling ç« èŠ‚çš„è¿™éƒ¨åˆ†:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
ç„¶åè¯•ä¸€è¯•ï¼"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
å¦‚æœå…¶å®ƒå‡½æ•°å¯ä»¥è¿”å› `Result`ï¼Œä¸ºä»€ä¹ˆ `main` å‡½æ•°ä¸èƒ½ï¼Ÿ"""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` å°†åˆ›å»ºä¸€ä¸ªæ–°çš„å®ä¾‹ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Ok` ã€‚
å®ƒåº”è¯¥åšä¸€äº›æ£€æŸ¥ï¼Œå¦‚æœæ£€æŸ¥åˆ°å¤±è´¥ï¼Œåˆ™è¿”å› `Err` ï¼Œå¦‚æœç¡®å®šä¸€åˆ‡æ­£å¸¸ï¼Œåˆ™è¿”å› `Ok` :)ã€‚"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
æç¤ºï¼šåœ¨ `main()` ä¸­äº§ç”Ÿäº†ä¸¤ç§ `Result` ç±»å‹ï¼Œå®ƒä»¬æ˜¯é€šè¿‡ `?` è¿ç®—ç¬¦è¿”å›çš„ã€‚
é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•åœ¨ `main()` ä¸­å£°æ˜ä¸€ä¸ªå®¹çº³è¿™ä¸¤è€…çš„è¿”å›ç±»å‹ï¼Ÿ

é¢å¤–æç¤ºï¼š`?` æ“ä½œç¬¦çš„åº•å±‚å®ç°å®é™…ä¸Šæ˜¯å¯¹é”™è¯¯å€¼è°ƒç”¨äº† `From::from` ï¼Œå°†å…¶è½¬æ¢ä¸º
äº† `Box<dyn error::Error>` ç±»å‹ã€‚å®ƒæ˜¯å¤šæ€çš„â€”â€”è¿™æ„å‘³ç€ä¸åŒç±»å‹çš„é”™è¯¯å¯ä»¥ä»åŒä¸€ä¸ªå‡½æ•°è¿”å›ï¼Œ
å› ä¸ºå®ƒä»¬éƒ½å®ç°äº†`error::Error`ç‰¹å¾ï¼Œè¡Œä¸ºéƒ½æ˜¯ä¸€è‡´çš„ã€‚
è¯·çœ‹è¿™æœ¬ä¹¦çš„è¿™ä¸€éƒ¨åˆ†ï¼š
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

è¿™ä¸ªç»ƒä¹ ä½¿ç”¨äº†ä¸€äº›è¯¾ç¨‹åæœŸæ‰ä¼šä»‹ç»åˆ°çš„æ¦‚å¿µï¼Œå¦‚ `Box` æŒ‡é’ˆå’Œ `From` ç‰¹å¾ã€‚
ç°åœ¨è¯¦ç»†äº†è§£å®ƒä»¬å¹¶ä¸é‡è¦ï¼Œä½†å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œå¯ä»¥æå‰é˜…è¯»ã€‚

é˜…è¯»æ›´å¤šè£…ç®±é”™è¯¯ï¼ˆboxing errorsï¼‰çš„å†…å®¹ï¼š
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

é˜…è¯»æ›´å¤šå…³äºä½¿ç”¨ `?` æ“ä½œç¬¦å’Œè£…ç®±é”™è¯¯çš„å†…å®¹ã€‚
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
è¿™ä¸ªç»ƒä¹ ä½¿ç”¨çš„æ˜¯æ¥è‡ªäº error 4 çš„ `PositiveNonzeroInteger` å®Œæ•´ç‰ˆæœ¬ã€‚

åœ¨ TODO è¦æ±‚ä½ ä¿®æ”¹çš„é‚£ä¸€è¡Œä¸‹é¢ï¼Œæœ‰ä¸€ä¸ªåœ¨ `Result` ä¸Šä½¿ç”¨ `map_err()` æ–¹æ³•å°†
ä¸€ç§ç±»å‹çš„é”™è¯¯è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„ä¾‹å­ã€‚å°è¯•åœ¨ `parse()` çš„ `Result` ä¸Šä½¿ç”¨ç±»ä¼¼çš„ä¸œè¥¿ã€‚
ä½ å¯èƒ½ä½¿ç”¨ `?` æ“ä½œç¬¦åœ¨å‡½æ•°ä¸­æå‰è¿”å›ï¼Œæˆ–è€…ä½¿ç”¨ `match` è¡¨è¾¾å¼ï¼Œä»¥åŠç­‰ç­‰å…¶å®ƒæ–¹æ³•ã€‚

ä½ å¯ä»¥åœ¨ `impl ParsePosNonzeroError` å†…åˆ›å»ºå¦ä¸€ä¸ªæ–¹æ³•æ¥é…åˆ `map_err()` ä½¿ç”¨ã€‚

åœ¨ `std::result` æ–‡æ¡£äº†è§£æ›´å¤šå…³äº `map_err()` çš„ä¿¡æ¯ï¼š
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Rust ä¸­çš„ Vector é€šè¿‡æ³›å‹æ¥åˆ›å»ºä»»æ„ç±»å‹çš„åŠ¨æ€æ•°ç»„ã€‚
æ‰€ä»¥ä½ è¦å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬è¦æŠŠä»€ä¹ˆç±»å‹çš„å…ƒç´ æ¨å…¥åˆ°è¿™ä¸ªæ•°ç»„é‡Œã€‚"""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
ç›®å‰æˆ‘ä»¬åªåŒ…è£…äº† 'u32' ç±»å‹çš„å€¼ã€‚
æˆ–è®¸æˆ‘ä»¬å¯ä»¥é€šè¿‡æŸç§æ–¹å¼æ¥ä¿®æ”¹å¯¹ç±»å‹çš„æ˜¾å¼å¼•ç”¨ï¼Ÿ

å¦‚æœä½ è¿˜æ²¡æœ‰å¤´ç»ªï¼šhttps://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

[[exercises]]
name = "generics3"
path = "exercises/generics/generics3.rs"
mode = "test"
hint = """
ä¸ºäº†æ‰¾åˆ°è§£å†³è¿™ä¸ªéš¾é¢˜çš„æœ€ä½³æ–¹æ³•ï¼Œä½ éœ€è¦å›æƒ³ä¸€ä¸‹æœ‰å…³ trait çš„çŸ¥è¯†ï¼Œç‰¹åˆ«æ˜¯ trait çš„ç»‘å®šè¯­æ³•â€”â€”å¯èƒ½
è¿˜éœ€è¦è¿™ä¸ªï¼š"use std::fmt::Display;"

è¿™ç»å¯¹æ¯”å‰ä¸¤ä¸ªç»ƒä¹ æ›´éš¾ï¼ä½ éœ€è¦ä½¿ ReportCard ç»“æ„é€šç”¨ï¼Œå¹¶æ‹¥æœ‰æ­£ç¡®çš„å±æ€§ï¼ŒåŒæ—¶
ä½ ä¹Ÿéœ€è¦ç¨å¾®æ”¹å˜ä¸€ä¸‹ç»“æ„çš„å®ç°â€¦â€¦åŠ æ²¹ğŸ’ªï¼
"""

# OPTIONS

[[exercises]]
name = "option1"
path = "exercises/option/option1.rs"
mode = "compile"
hint = """
æç¤º 1ï¼šäº†è§£ Option çš„ä¸€äº›æ–¹æ³•ï¼š
is_some
is_none
unwrap

å’Œï¼š
æ¨¡å¼åŒ¹é…

æç¤º 2ï¼šæ•°ç»„æ²¡æœ‰åˆé€‚çš„é»˜è®¤å€¼ï¼›åœ¨ä½¿ç”¨å‰éœ€è¦æ·»åŠ è¿™äº›å€¼ã€‚
"""

[[exercises]]
name = "option2"
path = "exercises/option/option2.rs"
mode = "compile"
hint = """
æŸ¥çœ‹ï¼š
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

è®°ä½ï¼Œå¯ä»¥å¤šæ¬¡å±‚å åœ°å¯¹ Options ä½¿ç”¨ if let æˆ– while let ã€‚
ä¾‹å¦‚: Some(Some(variable)) = variable2
ä¹Ÿå¯ä»¥å‚è€ƒä¸‹ Option::flatten
"""

[[exercises]]
name = "option3"
path = "exercises/option/option3.rs"
mode = "compile"
hint = """
ç¼–è¯‘å™¨è¯´ `match` è¯­å¥ä¸­å‘ç”Ÿäº†éƒ¨åˆ†ç§»åŠ¨ã€‚
æ€æ ·é¿å…è¿™ç§æƒ…å†µï¼Ÿç¼–è¯‘å™¨ä¹Ÿå·²ç»™å‡ºäº†æ‰€éœ€çš„ä¿®æ­£ã€‚
æŒ‰ç…§ç¼–è¯‘å™¨çš„å»ºè®®è¿›è¡Œä¿®æ­£åï¼Œè¯·é˜…è¯»ï¼šhttps://doc.rust-lang.org/std/keyword.ref.html"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
A discussion about Traits in Rust can be found at:
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
Notice how the trait takes ownership of 'self',and returns `Self'.
Try mutating the incoming string vector.

Vectors provide suitable methods for adding an element at the end. See
the documentation at: https://doc.rust-lang.org/std/vec/struct.Vec.html"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
You don't even need to write any code to test -- you can just test values and run that, even
though you wouldn't do that in real life :) `assert!` is a macro that needs an argument.
Depending on the value of the argument, `assert!` will do nothing (in which case the test will
pass) or `assert!` will panic (in which case the test will fail). So try giving different values
to `assert!` and see which ones compile, which ones pass, and which ones fail :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
Like the previous exercise, you don't need to write any code to get this test to compile and
run. `assert_eq!` is a macro that takes two arguments and compares them. Try giving it two
values that are equal! Try giving it two arguments that are different! Try giving it two values
that are of different types! Try switching which argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
You can call a function right where you're passing arguments to `assert!` -- so you could do
something like `assert!(having_fun())`. If you want to check that you indeed get false, you
can negate the result of what you're doing using `!`, like `assert!(!having_fun())`."""

# TEST 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = "No hints this time ;)"

# STANDARD LIBRARY TYPES

[[exercises]]
name = "box1"
path = "exercises/standard_library_types/box1.rs"
mode = "test"
hint = """
Step 1
The compiler's message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our `List` inside a `Box`. More details in the book here:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2
Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons "list builder".
Although the current list is one of integers (i32), feel free to change the definition
and try other types!
"""

[[exercises]]
name = "arc1"
path = "exercises/standard_library_types/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "iterators1"
path = "exercises/standard_library_types/iterators1.rs"
mode = "compile"
hint = """
Step 1:
We need to apply something to the collection `my_fav_fruits` before we start to go through
it. What could that be? Take a look at the struct definition for a vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html.
Step 2 & step 2.1:
Very similar to the lines above and below. You've got this!
Step 3:
An iterator goes through all elements in a collection, but what if we've run out of
elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/standard_library_types/iterators2.rs"
mode = "test"
hint = """
Step 1
The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.
The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.
The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2
Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to collect the iterator.

Step 3.
This is surprising similar to the previous solution. Collect is very powerful
and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/standard_library_types/iterators3.rs"
mode = "test"
hint = """
The divide function needs to return the correct error when even division is not
possible.

The division_results variable needs to be collected into a collection type.

The result_with_list function needs to return a single Result where the success
case is a vector of integers and the failure case is a DivisionError.

The list_of_results function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for how 
the `FromIterator` trait is used in `collect()`."""

[[exercises]]
name = "iterators4"
path = "exercises/standard_library_types/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a for loop that updates
a mutable variable. Or, you might write code utilizing recursion
and a match clause. In Rust you can take another functional
approach, computing the factorial elegantly with ranges and iterators."""

[[exercises]]
name = "iterators5"
path = "exercises/standard_library_types/iterators5.rs"
mode = "test"
hint = """
The documentation for the std::iter::Iterator trait contains numerous methods
that would be helpful here.

Return 0 from count_collection_iterator to make the code compile in order to
test count_iterator.

The collection variable in count_collection_iterator is a slice of HashMaps. It
needs to be converted into an iterator in order to use the iterator methods.

The fold method can be useful in the count_collection_iterator function.

For a further challenge, consult the documentation for Iterator to find
a different method that could make your code more compact than using fold."""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)


Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));`
Similar to the code in the example in the book that happens after the text
that says "We can use Arc<T> to fix this.". If not, give that a try! If you
do and would like more hints, keep reading!!


Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

Ok, so, real talk, this was actually tricky for *me* to do too. And
I could see a lot of different problems you might run into, so at this
point I'm not sure which one you've hit :)

Please open an issue if you're still running into a problem that
these hints are not helping you with, or if you've looked at the sample
answers and don't understand why they work and yours doesn't.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.
The way macros are written, it wants to see something between each
"macro arm", so it can separate them."""

# TEST 4

[[exercises]]
name = "quiz4"
path = "exercises/quiz4.rs"
mode = "test"
hint = "No hints this time ;)"

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Not every floating point value can be represented exactly in binary values in
memory. Take a look at the description of 
https://doc.rust-lang.org/stable/std/primitive.f32.html
When using the binary compare operators with floating points you won't compare
the floating point values but the binary representation in memory. This is 
usually not what you would like to do. 
See the suggestions of the clippy warning in compile output and use the
machine epsilon value...
https://doc.rust-lang.org/stable/std/primitive.f32.html#associatedconstant.EPSILON"""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over Option values are more clearly expressed as an `if let`"""

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Hint: Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Hint: Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add AsRef<str> as a trait bound to the functions."""

# ADVANCED ERRORS

[[exercises]]
name = "advanced_errs1"
path = "exercises/advanced_errors/advanced_errs1.rs"
mode = "test"
hint = """
This exercise uses an updated version of the code in errors6. The parsing
code is now in an implementation of the `FromStr` trait. Note that the
parsing code uses `?` directly, without any calls to `map_err()`. There is
one partial implementation of the `From` trait example that you should
complete.

Details: The `?` operator calls `From::from()` on the error type to convert
it to the error type of the return type of the surrounding function.

Hint: You will need to write another implementation of `From` that has a
different input type.
"""

[[exercises]]
name = "advanced_errs2"
path = "exercises/advanced_errors/advanced_errs2.rs"
mode = "test"
hint = """
This exercise demonstrates a few traits that are useful for custom error
types to implement. These traits make it easier for other code to consume
the custom error type.

Follow the steps in the comment near the top of the file. You will have to
supply a missing trait implementation, and complete a few incomplete ones.

You may find these pages to be helpful references:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/define_error_type.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/wrap_error.html

Hint: What trait must our error type have for `main()` to return the return
type that it returns?

Another hint: It's not necessary to implement any methods inside the missing
trait. (Some methods have default implementations that are supplied by the
trait.)

Another hint: Consult the tests to determine which error variants (and which
error message text) to produce for certain error conditions.

Challenge: There is one test that is marked `#[ignore]`. Can you supply the
missing code that will make it pass? You may want to consult the standard
library documentation for a certain trait for more hints.
"""
