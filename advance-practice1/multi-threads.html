<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>多线程版本 - Rust语言圣经(Rust Course)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/src/advance-practice1/multi-threads.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="构建多线程-web-服务器"><a class="header" href="#构建多线程-web-服务器">构建多线程 Web 服务器</a></h1>
<p>目前的单线程版本只能依次处理用户的请求：一时间只能处理一个请求连接。随着用户的请求数增多，可以预料的是排在后面的用户可能要等待数十秒甚至超时！</p>
<p>本章我们将解决这个问题，但是首先来模拟一个慢请求场景，看看单线程是否真的如此糟糕。</p>
<h2 id="基于单线程模拟慢请求"><a class="header" href="#基于单线程模拟慢请求">基于单线程模拟慢请求</a></h2>
<p>下面的代码中，使用 sleep 的方式让每次请求持续 5 秒，模拟真实的慢请求:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in main.rs
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
}
<span class="boring">}</span></code></pre></pre>
<p>由于增加了新的请求路径 <code>/sleep</code>，之前的 <code>if else</code> 被修改为 <code>match</code>，需要注意的是，由于 <code>match</code> 不会像方法那样自动做引用或者解引用，因此我们需要显式调用: <code>match &amp;request_line[..]</code> ，来获取所需的 <code>&amp;str</code> 类型。</p>
<p>可以看出，当用户访问 <code>/sleep</code> 时，请求会持续 5 秒后才返回，下面来试试，启动服务器后，打开你的浏览器，这次要分别打开两个页面(tab页): <code>http://127.0.0.1:7878/</code> 和 <code>http://127.0.0.1:7878/sleep</code>。</p>
<p>此时，如果我们连续访问 <code>/</code> 路径，那效果跟之前一样：立刻看到请求的页面。但假如先访问 <code>/sleep</code> ，接着在另一个页面访问 <code>/</code>，就会看到 <code>/</code> 的页面直到 5 秒后才会刷出来，验证了请求排队这个糟糕的事实。</p>
<p>至于如何解决，其实办法不少，本章我们来看看一个经典解决方案：线程池。</p>
<h2 id="使用线程池改善吞吐"><a class="header" href="#使用线程池改善吞吐">使用线程池改善吞吐</a></h2>
<p>线程池包含一组已生成的线程，它们时刻等待着接收并处理新的任务。当程序接收到新任务时，它会将线程池中的一个线程指派给该任务，在该线程忙着处理时，新来的任务会交给池中剩余的线程进行处理。最终，当执行任务的线程处理完后，它会被重新放入到线程池中，准备处理新任务。</p>
<p>假设线程池中包含 N 个线程，那么可以推断出，服务器将拥有并发处理 N 个请求连接的能力，从而增加服务器的吞吐量。</p>
<p>同时，我们将限制线程池中的线程数量，以保护服务器免受拒绝服务攻击（DoS）的影响：如果针对每个请求创建一个新线程，那么一个人向我们的服务器发出1000万个请求，会直接耗尽资源，导致后续用户的请求无法被处理，这也是拒绝服务名称的来源。</p>
<p>因此，还需对线程池进行一定的架构设计，首先是设定最大线程数的上限，其次维护一个请求队列。池中的线程去队列中依次弹出请求并处理。这样就可以同时并发处理 N 个请求，其中 N 是线程数。</p>
<p>但聪明的读者可能会想到，假如每个请求依然耗时很长，那请求队列依然会堆积，后续的用户请求还是需要等待较长的时间，毕竟你也就 N 个线程，但总归比单线程要强 N 倍吧 :D</p>
<p>当然，线程池依然是较为传统的提升吞吐方法，比较新的有：单线程异步 IO，例如 redis；多线程异步 IO，例如 Rust 的主流 web 框架。事实上，大家在下一个实战项目中，会看到相关技术的应用。</p>
<h3 id="为每个请求生成一个线程"><a class="header" href="#为每个请求生成一个线程">为每个请求生成一个线程</a></h3>
<p>这显然不是我们的最终方案，原因在于它会生成无上限的线程数，最终导致资源耗尽。但它确实是一个好的起点:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}</code></pre></pre>
<p>这种实现下，依次访问 <code>/sleep</code> 和 <code>/</code> 就无需再等待，不错的开始。</p>
<h3 id="限制创建线程的数量"><a class="header" href="#限制创建线程的数量">限制创建线程的数量</a></h3>
<p>原则上，我们希望在上面代码的基础上，尽量少的去修改，下面是一个假想的线程池 API 实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}</code></pre></pre>
<p>代码跟之前的类似，也非常简洁明了， <code>ThreadPool::new(4)</code> 创建一个包含 4 个线程的线程池，接着通过 <code>pool.execute</code> 去分发执行请求。</p>
<p>显然，上面的代码无法编译，下面来逐步实现。</p>
<h3 id="使用编译器驱动的方式开发-threadpool"><a class="header" href="#使用编译器驱动的方式开发-threadpool">使用编译器驱动的方式开发 ThreadPool</a></h3>
<p>你可能听说过测试驱动开发，但听过编译器驱动开发吗？来见识下 Rust 中的绝招吧。</p>
<p>检查之前的代码，看看报什么错:</p>
<pre><code class="language-shell">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>俗话说，不怕敌人很强，就怕他们不犯错，很好，编译器漏出了破绽。看起来我们需要实现 <code>ThreadPool</code> 类型。看起来，还需要添加一个库包，未来线程池的代码都将在这个独立的包中完成，甚至于未来你要实现其它的服务，也可以复用这个多线程库包。</p>
<p>创建 <code>src/lib.rs</code> 文件并写入如下代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}</span></code></pre></pre>
<p>接着在 <code>main.rs</code> 中引入:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs
use hello::ThreadPool;
<span class="boring">}</span></code></pre></pre>
<p>编译后依然报错:</p>
<pre><code class="language-shell">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>好，继续实现 <code>new</code> 函数 :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">}</span></code></pre></pre>
<p>继续检查：</p>
<pre><code class="language-shell">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>这个方法类似于 <code>thread::spawn</code>，用于将闭包中的任务交给某个空闲的线程去执行。</p>
<p>其实这里有一个小难点：<code>execute</code> 的参数是一个闭包，回忆下之前学过的内容，闭包作为参数时可以由三个特征进行约束: <code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>，选哪个就成为一个问题。由于 <code>execute</code> 在实现上类似 <code>thread::spawn</code>，我们可以参考下后者的签名如何声明。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
<span class="boring">}</span></code></pre></pre>
<p>可以看出，<code>spawn</code> 选择 <code>FnOnce</code> 作为 <code>F</code> 闭包的特征约束，原因是闭包作为任务只需被线程执行一次即可。</p>
<p><code>F</code> 还有一个特征约束 <code>Send</code> ，也可以照抄过来，毕竟闭包需要从一个线程传递到另一个线程，至于生命周期约束 <code>'static</code>，是因为我们并不知道线程需要多久时间来执行该任务。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ThreadPool {
    // --snip--
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在理解 <code>spawn</code> 后，就可以轻松写出如上的 <code>execute</code> 实现，注意这里的 <code>FnOnce()</code> 跟 <code>spawn</code> 有所不同，原因是要 <code>execute</code> 传入的闭包没有参数也没有返回值。</p>
<pre><code class="language-shell">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>成功编译，但在浏览器访问依然会报之前类似的错误，下面来实现 <code>execute</code>。</p>
<h3 id="new-还是-build"><a class="header" href="#new-还是-build"><code>new</code> 还是 <code>build</code></a></h3>
<p>关于 <code>ThreadPool</code> 的构造函数，存在两个选择 <code>new</code> 和 <code>build</code>。</p>
<p><code>new</code> 往往用于简单初始化一个实例，而 <code>build</code> 往往会完成更加复杂的构建工作，例如入门实战中的 <code>Config::build</code>。</p>
<p>在这个项目中，我们并不需要在初始化线程池的同时创建相应的线程，因此 <code>new</code> 是更适合的选择:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
<span class="boring">}</span></code></pre></pre>
<p>这里有两点值得注意:</p>
<ul>
<li><code>usize</code> 类型包含 <code>0</code>，但是创建没有任何线程的线程池显然是无意义的，因此做一下 <code>assert!</code> 验证</li>
<li><code>ThreadPool</code> 拥有不错的<a href="https://course.rs/basic/comment.html#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">文档注释</a>，甚至包含了可能 <code>panic</code> 的情况，通过 <code>cargo doc --open</code> 可以访问文档注释</li>
</ul>
<h3 id="存储线程"><a class="header" href="#存储线程">存储线程</a></h3>
<p>创建 <code>ThreadPool</code> 后，下一步就是存储具体的线程，既然要存放线程，一个绕不过去的问题就是：用什么类型来存放，例如假如使用 <code>Vec&lt;T&gt;</code>  来存储，那这个 <code>T</code> 应该是什么？</p>
<p>估计还得探索下 <code>thread::spawn</code> 的签名，毕竟它生成并返回一个线程:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
<span class="boring">}</span></code></pre></pre>
<p>看起来 <code>JoinHandle&lt;T&gt;</code> 是我们需要的，这里的 <code>T</code> 是传入的闭包任务所返回的，我们的任务无需任何返回，因此 <code>T</code> 直接使用 <code>()</code> 即可。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
<p>如上所示，最终我们使用 <code>Vec&lt;thread::JoinHandle&lt;()&gt;&gt;</code> 来存储线程，同时设定了容量上限 <code>with_capacity(size)</code>，该方法还可以提前分配好内存空间，比 <code>Vec::new</code> 的性能要更好一点。</p>
<h3 id="将代码从-threadpool-发送到线程中"><a class="header" href="#将代码从-threadpool-发送到线程中">将代码从 ThreadPool 发送到线程中</a></h3>
<p>上面的代码留下一个未实现的 <code>for</code> 循环，用于创建和存储线程。</p>
<p>学过多线程一章后，大家应该知道 <code>thread::spawn</code> 虽然是生成线程最好的方式，但是它会立即执行传入的任务，然而，在我们的使用场景中，创建线程和执行任务明显是要分离的，因此标准库看起来不再适合。</p>
<p>可以考虑创建一个 <code>Worker</code> 结构体，作为 <code>ThreadPool</code> 和任务线程联系的桥梁，它的任务是获得将要执行的代码，然后在具体的线程中去执行。想象一个场景：一个餐馆，<code>Worker</code> 等待顾客的点餐，然后将具体的点餐信息传递给厨房，感觉类似服务员？</p>
<p>引入 <code>Worker</code> 后，就无需再存储 <code>JoinHandle&lt;()&gt;</code> 实例，直接存储 <code>Worker</code> 实例：该实例内部会存储 <code>JoinHandle&lt;()&gt;</code>。下面是新的线程池创建流程:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        // 尚未实现..
        let thread = thread::spawn(|| {});
        // 每个 `Worker` 都拥有自己的唯一 id
        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>由于外部调用者无需知道 <code>Worker</code> 的存在，因此这里使用了私有的声明。</p>
<p>大家可以编译下代码，如果出错了，请仔细检查下，是否遗漏了什么，截止目前，代码是完全可以通过编译的，但是任务该怎么执行依然还没有实现。</p>
<h3 id="将请求发送给线程"><a class="header" href="#将请求发送给线程">将请求发送给线程</a></h3>
<p>在上面的代码中， <code>thread::spawn(|| {})</code> 还没有给予实质性的内容，现在一起来完善下。</p>
<p>首先 <code>Worker</code> 结构体需要从线程池 <code>ThreadPool</code> 的队列中获取待执行的代码，对于这类场景，消息传递非常适合：我们将使用消息通道( channel )作为任务队列。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
<p>阅读过之前内容的同学应该知道，消息通道有发送端和接收端，其中线程池 <code>ThreadPool</code> 持有发送端，通过 <code>execute</code> 方法来发送任务。那么问题来了，谁持有接收端呢？答案是 <code>Worker</code>，它的内部线程将接收任务，然后进行处理。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>看起来很美好，但是很不幸，它会报错:</p>
<pre><code class="language-shell">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>原因也很简单，<code>receiver</code> 并没有实现 <code>Copy</code>，因此它的所有权在第一次循环中，就被传入到第一个 <code>Worker</code> 实例中，后续自然无法再使用。</p>
<p>报错就解决呗，但 Rust 中的 channel 实现是 mpsc，即多生产者单消费者，因此我们无法通过克隆消费者的方式来修复这个错误。当然，发送多条消息给多个接收者也不在考虑范畴，该怎么办？似乎陷入了绝境。</p>
<p>雪上加霜的是，就算 <code>receiver</code> 可以克隆，但是你得保证同一个时间只有一个<code>receiver</code> 能接收消息，否则一个任务可能同时被多个 <code>Worker</code> 执行，因此多个线程需要安全的共享和使用 <code>receiver</code>，等等，安全的共享？听上去 <code>Arc</code> 这个多所有权结构非常适合，互斥使用？貌似 <code>Mutex</code> 很适合，结合一下，<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>，这不就是我们之前见过多次的线程安全类型吗？</p>
<p>总之，<code>Arc</code> 允许多个 <code>Worker</code> 同时持有 <code>receiver</code>，而 <code>Mutex</code> 可以确保一次只有一个 <code>Worker</code> 能从 <code>receiver</code> 接收消息。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
    }
}
<span class="boring">}</span></code></pre></pre>
<p>修改后，每一个 Worker 都可以安全的持有 <code>receiver</code>，同时不必担心一个任务会被重复执行多次，完美！</p>
<h3 id="实现-execute-方法"><a class="header" href="#实现-execute-方法">实现 execute 方法</a></h3>
<p>首先，需要为一个很长的类型创建一个别名, 有多长呢？</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">}</span></code></pre></pre>
<p>创建别名的威力暂时还看不到，敬请期待。总之，这里的工作很简单，将传入的任务包装成 <code>Job</code> 类型后，发送出去。</p>
<p>但是还没完，接收的代码也要完善下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>修改后，就可以不停地循环去接收任务，最后进行执行。还可以看到因为之前 <code>Job</code> 别名的引入， <code>new</code> 函数的签名才没有过度复杂，否则你将看到的是 <code>fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Box&lt;dyn FnOnce() + Send + 'static&gt;&gt;&gt;&gt;) -&gt; Worker</code> ，感受下类型别名的威力吧 :D</p>
<p><code>lock()</code> 方法可以获得一个 <code>Mutex</code> 锁，至于为何使用 <code>unwrap</code>，难道获取锁还能失败？没错，假如当前持有锁的线程 <code>panic</code> 了，那么这些等待锁的线程就会获取一个错误，因此 通过 <code>unwrap</code> 来让当前等待的线程 <code>panic</code> 是一个不错的解决方案，当然你还可以换成 <code>expect</code>。</p>
<p>一旦获取到锁里的内容 <code>mpsc::Receiver&lt;Job&gt;&gt;</code> 后，就可以调用其上的 <code>recv</code> 方法来接收消息，依然是一个 <code>unwrap</code>，原因在于持有发送端的线程可能会被关闭，这种情况下直接 <code>panic</code> 也是不错的。</p>
<p><code>recv</code> 的调用过程是阻塞的，意味着若没有任何任务，那当前的调用线程将一直等待，直到接收到新的任务。<code>Mutex&lt;T&gt;</code> 可以保证同一个任务只会被一个 Worker 获取，不会被重复执行。</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>终于，程序如愿运行起来，我们的线程池可以并发处理任务了！从打印的数字可以看到，只有 4 个线程去执行任务，符合我们对线程池的要求，这样再也不用担心系统的线程资源会被消耗殆尽了！</p>
<blockquote>
<p>注意： 出于缓存的考虑，有些浏览器会对多次同样的请求进行顺序的执行，因此你可能还是会遇到访问 <code>/sleep</code> 后，就无法访问另一个 <code>/sleep</code> 的问题 :(</p>
</blockquote>
<h2 id="while-let-的巨大陷阱"><a class="header" href="#while-let-的巨大陷阱">while let 的巨大陷阱</a></h2>
<p>还有一个问题，为啥之前我们不用 <code>while let</code> 来循环？例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这段代码编译起来没问题，但是并不会产生我们预期的结果：后续请求依然需要等待慢请求的处理完成后，才能被处理。奇怪吧，仅仅是从 <code>let</code> 改成 <code>while let</code> 就会变成这样？大家可以思考下为什么会这样，具体答案会在下一章节末尾给出，这里先出给一个小提示：<code>Mutex</code> 获取的锁在作用域结束后才会被释放。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../advance-practice1/web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advance-practice1/graceful-shutdown.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../advance-practice1/web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advance-practice1/graceful-shutdown.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../assets/custom2.js"></script>
        <script src="../assets/bigPicture.js"></script>


    </div>
    </body>
</html>
